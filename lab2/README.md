# report
## interrupt
报告中运行结果与分析部分，请回答下列问题。
（1）你最初认为运行结果会怎么样？写出你猜测的结果。
    SIGINT: 父进程收到后退出sleep, 并向子进程发送对应信号; 子进程进入handle后退出.
    SIGQUIT: 同SIGINT.
    SIGALRM: 在alarm计时结束后, 向子进程发送对应信号; 子进程进入handle后退出.
（2）实际的结果什么样？有什么特点？在接收不同中断前后有什么差别？请将5秒内中断和5秒后中断的运行结果截图，并对产生该现象的原因进行分析。
    SIGINT, SIGQUIT: 该信号会向进程组内的所有进程发送, 导致子进程实际被SIGINT/SIGQUIT中止, 而不是信号16/17.
    ![alt text](image/sigquit.png)
    SIGALRM: 同最初认为得一致.
    ![alt text](image/sigalrm.png)
（3）改为闹钟中断后，程序运行的结果是什么样子？与之前有什么不同？
    见(2).
（4）kill 命令在程序中使用了几次？每次的作用是什么？执行后的现象是什么？
    两次, 分别向子进程发送信号16, 17. 执行后子进程若没有退出则进入handle.
（5）使用kill 命令可以在进程的外部杀死进程。进程怎样能主动退出？这两种退出方式哪种更好一些？
    进程主动退出:
        exit: 返回状态码, 会执行注册在atexit的函数, 刷新并关闭io流.
        \_exit: 立即终止, 不调用atexit, 直接返回状态码, 不刷新或关闭io流.
        return: 返回状态码
    主动退出好一点, 可以清理资源, 避免资源泄漏等问题. 

## pipe
报告中运行结果与分析部分，请回答下列问题。
(1)你最初认为运行结果会怎么样？
    加锁: 先写入2000个A, 再写入2000个B
    不加锁: 随机写入
(2)实际的结果什么样？有什么特点？试对产生该现象的原因进行分析。
    同最初认为得一致.
    lockf(int fd, int cmd, off_t len);
(3)实验中管道通信是怎样实现同步与互斥的？如果不控制同步与互斥会发生什么后果？
    lockf对文件加锁. 交替输出

## mem
在实验总结部分，要包括如下内容：
（1）对涉及的3个算法进行比较，包括算法思想、算法的优缺点、在实现上如何提高算法的查找性能。
    BF:
        最佳适配算法在空闲内存块列表中查找最小的、能够满足请求的内存块。它选择最接近请求大小的空闲块，以减少内存浪费.
        能够减少内存碎片，因为它选择最小的适配块; 在某些情况下，可以更有效地利用内存.
        查找时间较长，因为需要遍历整个空闲块列表以找到最合适的块; 可能会产生大量的小碎片，因为它总是选择最小的适配块.
        使用平衡树或堆等数据结构来维护空闲块列表，以加快查找速度; 对空闲块列表进行排序，以便更快地找到适配块.
    FF:
        首次适配算法从空闲块列表的头部开始查找，选择第一个能够满足请求的内存块。它不需要遍历整个列表，只要找到一个适配块就立即分配。
        查找速度较快，因为它只需要找到第一个适配块; 实现简单，开销较低。
        可能会产生较多的外部碎片，因为它总是选择第一个适配块; 空闲块列表的前部可能会频繁使用，导致内存分配不均衡。
        使用分区空闲块列表，将空闲块按大小分类，以减少查找范围; 定期进行内存紧缩，合并相邻的空闲块，减少碎片。
    WF:
        最坏适配算法在空闲块列表中查找最大的、能够满足请求的内存块。它选择最大的适配块，以便留下较大的剩余块，减少碎片。
        能够减少内存碎片，因为它选择最大的适配块，留下较大的剩余块; 在某些情况下，可以更有效地利用内存。
        查找时间较长，因为需要遍历整个空闲块列表以找到最大的块; 可能会导致大块内存被频繁分割，产生较多的外部碎片。
        使用平衡树或堆等数据结构来维护空闲块列表，以加快查找速度; 对空闲块列表进行排序，以便更快地找到最大的块。

（2）3种算法的空闲块排序分别是如何实现的。
    BF, WF: 按空闲块的大小排序.
    FF: 按地址排序

（3）结合实验，举例说明什么是内碎片、外碎片，紧缩功能解决的是什么碎片。
    内碎片: 分配给进程的内存块中未被使用的部分.
    外碎片: 内存中未分配的空闲块分散在已分配的内存块之间, 导致无法满足大块内存请求.

    外碎片.
    !!内存紧缩
（4）在回收内存时，空闲块合并是如何实现的。
    检查该内存块的相邻块是否空闲.
    !!内存块合并

## page
在实验总结部分，要包括如下内容：
（1）从实现和性能方面，比较分析FIFO和LRU算法。
    FIFO: 将使用的内存组织成队列, 当内存已满时移除队列头的页面. 实现简单, 但性能较差
    LRU: 维护一个counter. 实现复杂, 但利用了程序的局部性原理, 效果更好
（2）LRU算法是基于程序的局部性原理而提出的算法，你模拟实现的LRU算法有没有体现出该特点？如果有，是如何实现的？
    有. 对每个内存中的页面维护一个counter, 其数值代表任务页面队列的下标.
（3）在设计内存管理程序时,应如何提高内存利用率。
    内存紧缩、合并空闲块、内存池、延迟合并

# BUGS

## interrupt
父进程接收SIGINT后子进程也会被SIGINT中止
SIGALRM则不会, 子进程会进入预设的sig handler.

这是因为SIGINT会向同一进程组的所有进程发送.

## macro
```
#define A 1

#define TOSTRING(x)   #x
#define TOTOSTRING(x) TOSTRING(X)

char a[] = "Hello " TOSTRING(A)   "\n"; // A will not be replaced.
char b[] = "Hello " TOTOSTRING(A) "\n"; // A will.
```

## page
FIFO的命中率与LRU的差不多?
如何构造具有时间局部性的序列? 设定固定的序列集